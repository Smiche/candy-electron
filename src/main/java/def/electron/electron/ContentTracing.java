package def.electron.electron;
import def.js.Function;
/**
	 * The content-tracing module is used to collect tracing data generated by the underlying Chromium content module.
	 * This module does not include a web interface so you need to open chrome://tracing/
	 * in a Chrome browser and load the generated file to view the result.
	 */
@jsweet.lang.Interface
public abstract class ContentTracing extends def.js.Object {
    /**
		 * Get a set of category groups. The category groups can change as new code paths are reached.
		 *
		 * @param callback Called once all child processes have acknowledged the getCategories request.
		 */
    native public void getCategories(java.util.function.Consumer<String[]> callback);
    /**
		 * Start recording on all processes. Recording begins immediately locally and asynchronously
		 * on child processes as soon as they receive the EnableRecording request.
		 *
		 * @param callback Called once all child processes have acknowledged the startRecording request.
		 */
    native public void startRecording(ContentTracingOptions options, Function callback);
    /**
		 * Stop recording on all processes. Child processes typically are caching trace data and
		 * only rarely flush and send trace data back to the main process. That is because it may
		 * be an expensive operation to send the trace data over IPC, and we would like to avoid
		 * much runtime overhead of tracing. So, to end tracing, we must asynchronously ask all
		 * child processes to flush any pending trace data.
		 *
		 * @param resultFilePath Trace data will be written into this file if it is not empty,
		 * or into a temporary file.
		 * @param callback Called once all child processes have acknowledged the stopRecording request.
		 */
    native public void stopRecording(String resultFilePath, java.util.function.Consumer<String> callback);
    /**
		 * Start monitoring on all processes. Monitoring begins immediately locally and asynchronously
		 * on child processes as soon as they receive the startMonitoring request.
		 *
		 * @param callback Called once all child processes have acked to the startMonitoring request.
		 */
    native public void startMonitoring(ContentTracingOptions options, Function callback);
    /**
		 * Stop monitoring on all processes.
		 *
		 * @param callback Called once all child processes have acknowledged the stopMonitoring request.
		 */
    native public void stopMonitoring(Function callback);
    /**
		 * Get the current monitoring traced data. Child processes typically are caching trace data
		 * and only rarely flush and send trace data back to the main process. That is because it may
		 * be an expensive operation to send the trace data over IPC, and we would like to avoid much
		 * runtime overhead of tracing. So, to end tracing, we must asynchronously ask all child
		 * processes to flush any pending trace data.
		 *
		 * @param callback Called once all child processes have acknowledged the captureMonitoringSnapshot request.
		 */
    native public void captureMonitoringSnapshot(String resultFilePath, java.util.function.Consumer<String> callback);
    /**
		 * Get the maximum usage across processes of trace buffer as a percentage of the full state.
		 *
		 * @param callback Called when the TraceBufferUsage value is determined.
		 */
    native public void getTraceBufferUsage(Function callback);
    /**
		 * @param callback Called every time the given event occurs on any process.
		 */
    native public void setWatchEvent(String categoryName, String eventName, Function callback);
    /**
		 * Cancel the watch event. This may lead to a race condition with the watch event callback if tracing is enabled.
		 */
    native public void cancelWatchEvent();
}

